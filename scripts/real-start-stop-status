#!/bin/sh

# Default display name
DNAME="${SYNOPKG_PKGNAME}"

if [ "$SYNOPKG_DSM_VERSION_MAJOR" -lt 7 ]; then
    # define SYNOPKG_PKGVAR for forward compatibility
    SYNOPKG_PKGVAR="${SYNOPKG_PKGDEST}/var"
fi

# Source package specific variable and functions
SVC_SETUP=$(dirname $0)"/service-setup"
if [ -r "${SVC_SETUP}" ]; then
    . "${SVC_SETUP}"
fi

configure_tun()
{
    echo "Checking for TUN device" >> "${LOG_FILE}"
    # Create /dev/net/tun if needed
    if ( [ ! -c /dev/net/tun ] ); then
        if ( [ ! -d /dev/net ] ); then
            mkdir -m 755 /dev/net
        fi
        echo "Adding TUN device" >> "${LOG_FILE}"
        mknod /dev/net/tun c 10 200
        chmod 0755 /dev/net/tun
    fi

    # Load TUN kernel module
    if ( !( lsmod | grep -q "^tun\s" ) ); then
        echo "Loading TUN kernel module" >> "${LOG_FILE}"
        insmod /lib/modules/tun.ko
    fi
}

add_source() {
    kver=$(uname -r | sed 's/+//')
    
    # Copy .so files if not exist
    cp -n "${SYNOPKG_PKGDEST}/iptables/${kver}/usr/lib/iptables/"*.so "/usr/lib/iptables/" 2>/dev/null || true
    
    # Load kernel module, error if failed
    local module_path="${SYNOPKG_PKGDEST}/iptables/${kver}/usr/lib/modules/xt_connmark.ko"
    [ -f "$module_path" ] && ! lsmod | grep -q "xt_connmark" && insmod "$module_path" || {
        echo "ERROR: Load kernel module failed" >> "${LOG_FILE}"
        return 1
    }
}

remove_source() {
    # Unload kernel module
    rmmod xt_connmark 2>/dev/null || true
}

# Invoke shell function if available
call_func ()
{
    FUNC=$1
    if type "${FUNC}" 2>/dev/null | grep -q 'function' 2>/dev/null; then
        echo "Begin ${FUNC}" >> ${LOG_FILE}
        eval ${FUNC}         >> ${LOG_FILE}
        echo "End ${FUNC}"   >> ${LOG_FILE}
    fi
}


start_daemon ()
{
    i=0
    if [ -z "${SVC_QUIET}" ]; then
        if [ -z "${SVC_KEEP_LOG}" ]; then
            date > ${LOG_FILE}
        else
            date >> ${LOG_FILE}
        fi
    fi
    call_func "service_prestart"
    printf "%s" "$SERVICE_COMMAND" | while read -r service || [ -n "$service" ]
    do
        i=$((i + 1))
        if [ -z "${SVC_QUIET}" ]; then
            echo "Starting ${DNAME} command ${service}" >> ${LOG_FILE}
        fi
        if [ -n "${service}" ]; then
            if [ -n "${SVC_NO_REDIRECT}" ]; then
                OUT="/dev/null"
            else
                OUT="${LOG_FILE}"
            fi
            if [ -n "${USER}" -a -n "${SYNOPKG_DSM_VERSION_MAJOR}" -a "$SYNOPKG_DSM_VERSION_MAJOR" -lt 6 ]; then
                if [ -z "${SVC_CWD}" ]; then
                    SVC_CD=""
                else
                    SVC_CD="cd ${SVC_CWD}; "
                fi
                if [ -n "${SYNOPKG_DSM_VERSION_MAJOR}" ] && [ "${SYNOPKG_DSM_VERSION_MAJOR}" -lt 7 ]; then
                    SU="su ${EFF_USER} -s"
                else
                    SU=""
                fi
                if [ -z "${SVC_BACKGROUND}" ]; then
                    $SU /bin/sh -c "${SVC_CD}${service}" >> ${OUT} 2>&1
                else
                    $SU /bin/sh -c "${SVC_CD}${service}" >> ${OUT} 2>&1 &
                fi

            else
                # DSM 6 user is set by conf/privilege
                if [ -n "${SVC_CWD}" ]; then
                    cd "${SVC_CWD}"
                fi
                if [ -z "${SVC_BACKGROUND}" ]; then
                    ${service} >> ${OUT} 2>&1
                else
                    ${service} >> ${OUT} 2>&1 &
                fi
            fi
            if [ -n "${SVC_WRITE_PID}" -a -n "${SVC_BACKGROUND}" -a -n "${PID_FILE}" ]; then
                [ $i -eq 1 ] && echo -ne "$!" > ${PID_FILE} || echo -ne " $!" >> ${PID_FILE}
            else
                wait_for_status 0 ${SVC_WAIT_TIMEOUT:=20}
            fi
        fi
    done
}

stop_daemon ()
{
    if [ -n "${PID_FILE}" -a -r "${PID_FILE}" ]; then
        for pid in $(cat "${PID_FILE}")
        do
            if [ -z "${SVC_QUIET}" ]; then
                date >> ${LOG_FILE}
                echo "Stopping ${DNAME} service : $(ps -p${pid} -o comm=) (${pid})" >> ${LOG_FILE}
            fi
            kill -TERM ${pid} >> ${LOG_FILE} 2>&1
            wait_for_status 1 ${SVC_WAIT_TIMEOUT:=20} ${pid} || kill -KILL ${pid} >> ${LOG_FILE} 2>&1
        done
        if [ -f "${PID_FILE}" ]; then
            rm -f "${PID_FILE}" > /dev/null
        fi
    fi
    call_func "service_poststop"
}

#------------------------------------------------------
# daemon_status()
#     $1: PID to check, if empty use ${PID_FILE}
# status: Keeps track of kill -0 exit status
#
# Return 0 when all pid are OK, else return 1
#------------------------------------------------------
daemon_status ()
{
if [ -f "${PID_FILE}" ]; then
    status=0
    [ -z "${1}" ] && pid_list=$(cat ${PID_FILE} 2>/dev/null) || pid_list=${1}
    if [ -n "${pid_list}" ]; then
        for pid in ${pid_list}
        do
           kill -0 ${pid} > /dev/null 2>&1
           let status=$status+$?
        done
        if [ $status -ne 0 ]; then
           rm -f "${PID_FILE}" > /dev/null
           return 1
        else
           return 0
        fi
    else
        return 1
    fi
else
    status=$(/usr/syno/bin/synosystemctl get-active-status pkg-netbird)
    if [ "$status" == active ]; then
        return 0
    else
        return 1 
    fi
fi
}

#------------------------------------------------------
# wait_for_status()
#      $1: expected return from daemon_status() call
#      $2: timeout (e.g. number of loop to be done)
#      $3: PID to check being passed to daemon_status()
# counter: Number of 1sec iteration to wait until
#          the return value from daemon_status()
#          match expected value
#
# Wait for a duration of $counter seconds for the
# return value from daemon_status().  If it match
# return 0 else return 1 if wait time is over.
#------------------------------------------------------
wait_for_status ()
{
    # default value: 20 seconds
    counter=${2}
    counter=${counter:=20}
    while [ ${counter} -gt 0 ]; do
        daemon_status ${3}
        [ $? -eq $1 ] && return
        let counter=counter-1
        sleep 1
    done
    return 1
}

case $1 in
    start)
        if [ "${SYNOPKG_PKGNAME}" != "Netbird" ]; then
              exit 1
        fi
        if [[ `id -u` -eq 0 ]]; then
            echo -e "⚠️本套件将以root权限运行！This package will run with root privileges!" | tee -a $SYNOPKG_TEMP_LOGFILE
        else
            echo -e "需要root权限启动：请安装SimplePermissionManager（授权管理器）套件并激活它。<br>Need root：Please install SimplePermissionManager package and activate it.<br><br>或SSH修复权限，仅对本次安装有效(Or SSH repair permission，valid only now)：<br>sudo sed -i 's/package/root/g' /var/packages/Netbird/conf/privilege" | tee -a $SYNOPKG_TEMP_LOGFILE
            exit 0
        fi
        if daemon_status; then
            echo "${DNAME} is already running" >> ${LOG_FILE}
            exit 0
        else
            echo "Starting ${DNAME} ..." >> ${LOG_FILE}
            if [ ! -f "${CONFIG_FILE}" ]; then
                configure_tun
                add_source
                start_daemon
            else
                configure_tun
                add_source 
                synosystemctl start pkg-netbird
            fi
            exit $?
        fi
        ;;
    stop)
        if daemon_status; then
            echo "Stopping ${DNAME} ..." >> ${LOG_FILE}
            if [ ! -f "${CONFIG_FILE}" ]; then
                stop_daemon
                remove_source
            else
                synosystemctl stop pkg-netbird
                remove_source
            fi
            exit $?
        else
            echo "${DNAME} is not running" >> ${LOG_FILE}
            exit 0
        fi
        ;;
    status)
        if daemon_status; then
            echo "${DNAME} is running"
            exit 0
        else
            echo "${DNAME} is not running"
            exit 3
        fi
        ;;
    log)
        # log output for DSM < 6
        if [ -n "${LOG_FILE}" -a -r "${LOG_FILE}" ]; then
            # Shorten long logs to last 100 lines
            TEMP_LOG_FILE="${SYNOPKG_PKGVAR}/${SYNOPKG_PKGNAME}_temp.log"
            # Clear any previous log
            echo "Full log: ${LOG_FILE}" > "${TEMP_LOG_FILE}"
            tail -n100 "${LOG_FILE}" >> "${TEMP_LOG_FILE}"
            echo "${TEMP_LOG_FILE}"
        fi
        exit 0
        ;;
    *)
        exit 1
        ;;
esac
